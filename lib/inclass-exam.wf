# -*- Tcl -*-
########################################################################
# Inclass-Exam workflow, designed similar to online-exam
# ======================================================
#
# Defining exams: This workflow lets a lecturer choose from a
# predefined set of exam questions, which are typically open text,
# short text, single or multiple choice questions.  The lecturer
# selects test questions via drag and drop. The lecturer can perform a
# test run of the created exam, and can get the results via a result
# table.
#
# Publishing and closing exams: When a lecturer is satisfied with the
# exam, the exam can be published. In this step, all answers of the
# testing phase are deleted. In the process of publishing, the link to
# start the exam is offered to the user.  When the exam is published,
# the lecturer can see the incoming answers in the report by refreshing
# the page. When the exam is done, it is unpublished. The workflow
# offers the lecturer to see a summary of the results in form of a
# table (an to download the results via csv), or the lecturer can
# produce a printer friendly version of the answers.
#
# An admin might wish to add the following entries to the folder to ease
# creation of exercises and exams
#
#   {clear_menu -menu New}
#
#   {entry -name New.Item.TextInteraction -form en:edit-interaction.wf -query p.item_type=Text}
#   {entry -name New.Item.ShortTextInteraction -form en:edit-interaction.wf -query p.item_type=ShortText}
#   {entry -name New.Item.SCInteraction -form en:edit-interaction.wf -query p.item_type=SC}
#   {entry -name New.Item.MCInteraction -form en:edit-interaction.wf -query p.item_type=MC}
#   {entry -name New.Item.ReorderInteraction -form en:edit-interaction.wf -query p.item_type=Reorder}
#   {entry -name New.Item.UploadInteraction -form en:edit-interaction.wf -query p.item_type=Upload}
#
#   {entry -name New.App.Exam -label "Inclass Exam" -form en:inclass-exam.wf}
#
# Alternatively, one can use the programmatic setup for the menubar
# via config=test-items in case a site wants to change all setups in
# all instances for menubars by updating a single file.
#
#   {config -use test-items}
#
# The policy has to allow the following methods on FormPages:
#
#  - "answer" (for students),
#  - "proctor" (for students),
#  - "view-my-exam" (for students),
#  - "edit" (for students),
#  - "poll" (for lecturers),
#  - "print-answers" (for lecturers),
#  - "print-answer-table" (for lecturers),
#  - "print-participants" (for lecturers),
#  - "exam-summary" (for lecturers),
#  - "delete" (for lecturers),
#  - "qrcode" (for lecturers)
#
# Gustaf Neumann, Feb 2012-2021
########################################################################
set :autoname 1   ;# to avoid editable name field
set :policy ::xowf::test_item::test-item-policy-publish
set :debug 0
set :live_updates 1

Action select -next_state created -label #xowf.online-exam-select# \
    -title #xowf.online-exam-title-select#
Action publish -next_state published -state_safe true -label #xowf.online-exam-publish# \
    -title #xowf.online-exam-title-publish#
Action unpublish -next_state done -state_safe true -label #xowf.online-exam-unpublish#
Action republish -next_state published -label #xowf.online-exam-republish# \
    -title #xowf.online-exam-title-republish#
Action restart -next_state initial -label #xowf.restart# \
    -title #xowf.online-exam-title-restart#
Action open_submission_review -next_state submission_review -label #xowf.open_submission_review# \
    -title #xowf.open_submission_review_title#
Action close_submission_review -next_state done -label #xowf.close_submission_review# \
    -title #xowf.close_submission_review_title#

State parameter {
  {extra_css {/resources/xowf/test-item.css}}
}
State initial -actions {select} -form en:select_question.form -view_method edit
State created -actions {publish restart} -form_loader load_form -view_method edit \
    -form "#xowf.inclass-exam-draft_exam#"
State published -actions {unpublish} -form_loader load_form -view_method edit \
    -form "#xowf.inclass-exam-open#"
State done -actions {republish open_submission_review} \
    -in_role swa {
      -actions {republish open_submission_review restart}
    } \
    -form_loader load_form -view_method edit \
    -form "#xowf.inclass-exam-closed#"
State submission_review -actions {close_submission_review} -form_loader load_form -view_method edit \
    -form "#xowf.inclass-exam-review#"

########################################################################
# Activate action select: After the lecturer has selected the
# exercises, the answer workflow is created.
#
select proc activate {obj} {
  xowf::test_item::answer_manager create_workflow \
      -answer_workflow /packages/xowf/lib/inclass-exam-answer.wf \
      $obj
}

########################################################################
# Activate action publish: delete all responses for the workflow and
# publish user participation link.
#
publish proc activate {obj} {
  xowf::test_item::answer_manager delete_all_answer_data $obj
  :publish_link $obj
}

########################################################################
# Activate action republish: publish user participation link.
#
republish proc activate {obj} {
  :publish_link $obj
}

########################################################################
# When the user un-publishes an exam, just the user participation
# link should be removed for the users
#
unpublish proc activate {obj} {
  :unpublish_link $obj
}

########################################################################
# When the user restarts an exam, make sure that already scheduled
# atjobs are removed.
#
restart proc activate {obj} {
  xowf::test_item::answer_manager delete_scheduled_atjobs $obj
}

########################################################################
# When the user opens the submission review, offer a link.
#
open_submission_review proc activate {obj} {
  set aLink [$obj pretty_link -query m=view-my-exam]
  $obj util_user_message -html -message \
      "[$obj name] exam review is available as <a target='_blank' href='[ns_quotehtml $aLink]'>[ns_quotehtml $aLink]</a>"
}

########################################################################
# publish_link: make the user participation link available for the
# target group
#
Action instproc publish_link {obj} {
  set aLink [$obj pretty_link -query m=answer]
  $obj util_user_message -html \
      -message "[$obj name] is available as <a target='_blank' href='[ns_quotehtml $aLink]'>[ns_quotehtml $aLink]</a>"
  # TODO: make it happen in the LMS
}
########################################################################
# unpublish_link: remove the user participation link for the target
# group
#
Action instproc unpublish_link {obj} {
  $obj util_user_message -html -message "[$obj name] is closed</a>"
  # TODO: make it happen in the LMS
}

########################################################################
# form loader: create dynamically a form containing the disabled
# questions as a preview and the survey results (the results can be
# refreshed).
#
:proc load_form {ctx title} {
  set obj [$ctx object]
  set state [$obj property _state]
  set proctoring [$obj property proctoring 0]

  set combined_form_info [::xowf::test_item::question_manager combined_question_form -with_numbers $obj]
  set fullQuestionForm [dict get $combined_form_info form]
  set full_fc [dict get $combined_form_info disabled_form_constraints]

  #:log  fullQuestionForm=$fullQuestionForm
  set text "<h3>$title</h3>"
  set menu ""

  set text [::xowf::test_item::question_manager exam_info_block \
                -combined_form_info $combined_form_info \
                $obj]
  set detail_link [$obj pretty_link -query m=exam-summary]
  append text "<p><a class='btn btn-default' href='$detail_link'>#xowf.detailed_summary#</a></p>"

  set wf [xowf::test_item::answer_manager get_answer_wf $obj]
  if {$wf eq ""} {
    :msg "cannot get current workflow for [$obj name]"
    set tLink "."
    set aLink "."
  } else {
    #
    # Always compute the test-run and answer link.
    #
    set wf_pretty_link [$wf pretty_link]
    set tLink [export_vars -base $wf_pretty_link {
      {m create-new} {p.return_url "[::xo::cc url]"} {p.try_out_mode 1} {title "[$obj title]"}
    }]
    set aLink [$obj pretty_link -query m=answer]

    if {$proctoring} {
      #
      # send link via "m=proctor"
      #
      set tLink [export_vars -base [$obj pretty_link] {
        {m proctor} {link "$tLink&p.proctor=1"}
      }]
      #
      # We could send answer link ("aLink") as well this way, but we
      # want to keep the link short, therefore, we handle the proctor
      # link inside the www-answer method.
      #
    }

    set answers [xowf::test_item::answer_manager get_answers $wf]

    #
    # Per default, the entries are disabled. When there are answers,
    # these will be enabled.
    #
    set link_disabled [expr {[llength $answers] == 0 ? "link-disabled" : ""}]
    set md [subst {
      listing      {obj $wf  m list label #xowf.online-exam-exam_instances# glyph list}
      participants {obj $obj m print-participants label #xowf.Participants# glyph user}
      protocol     {obj $obj m print-answers label #xowf.online-exam-protocol# glyph list-alt}
      results      {obj $obj m print-answer-table label #xowf.online-exam-results-table# glyph th-list}
    }]

    if {![acs_user::site_wide_admin_p -user_id [::xo::cc user_id]]} {
      dict unset md listing
    }
    dict unset md results

    set menu ""
    dict for {name d} $md {
      set href [[dict get $d obj] pretty_link -query m=[dict get $d m]]
      append menu "<a class='list-group-item $link_disabled' href='[ns_quotehtml $href]'>" \
          "<span class='glyphicon glyphicon-[dict get $d glyph]'></span> [dict get $d label]</a>\n"
    }
  }

  switch $state {
    "created" -
    "done" -
    "submission_review" -
    "published" {
      #
      # In inclass cases, never show all questions on screen, since
      # the lecturer might have the screen on the projector.
      #
      template::add_script -src urn:ad:js:bootstrap3
      set fullQuestionForm [subst {
        <button type="button" class="btn btn-default btn-sm dropdown-toggle" data-toggle="collapse" data-target="#questions">#xowf.questions# <span class="caret"></span></button>
        <div id="questions" class="collapse">
        $fullQuestionForm
        </div>
      }]
    }
  }

  set extraAction ""
  switch $state {
    "created"   {
      append extraAction "<br>" \
          "#xowf.online-exam-try_out# " \
          "<a class='btn btn-default' href='[ns_quotehtml $tLink]' target=”_blank”>#xowf.testrun#</a>"
    }
    "published" {
      append extraAction "<br>" \
          "#xowf.online-exam-can_answer# " \
          "<a class='answer' href='$aLink'>$aLink</a>"
    }
  }

  set www_method [xo::cc query_parameter m]
  if {$www_method ni {edit view}} {
    set marked ""
  } else {
    set answerStatus ""
    set marked ""

    if {$state in {published done submission_review} || [llength $answers] > 0 } {
      if {$state eq "done"} {
        [$ctx object] setCSSDefaults
        set marked [xowf::test_item::answer_manager marked_results -obj $obj -wf $wf $combined_form_info]
        set marked ""  ;# not needed right now
      }
      set answerStatus [xowf::test_item::answer_manager answers_panel  \
                            -heading "#xowf.online-exam-submitted_exams_heading#" \
                            -submission_msg "#xowf.online-exam-submitted_exams_msg#" \
                            -polling=[expr {${:live_updates} && $state ni {initial created done}}] \
                            -manager_obj $obj \
                            -target_state done \
                            -extra_text $menu \
                            -wf $wf]
    }

    set qrCode ""
    set countdownHTML ""
    if {$state eq "published"} {
      set src [$obj pretty_link -query m=qrcode]
      set qrCode [subst {<div><img class="img-thumbnail qrcode" src="[ns_quotehtml $src]" ></div>}]
      set target_time [xowf::test_item::question_manager exam_target_time \
                           -manager $obj -base_time [$obj last_modified]]
      set countdownHTML [xowf::test_item::answer_manager countdown_timer \
                             -target_time $target_time -id "countdown"]
    }

    # Remove wrapping forms
    regsub -all {</?form[^>]*>} $fullQuestionForm {} fullQuestionForm

    append text [subst {
      <div class='container-fluid'><div class='row'>
      <div class="col-sm-9">$answerStatus</div>
      <div class="col-sm-3">$qrCode</div>
      <div class="col-sm-9 quiz-preview">$fullQuestionForm</div>
      <div class="col-sm-6">$countdownHTML</div>
      </div></div>
    }]
  }

  set footer " $extraAction"

  #-form [subst {<form>$text<div class='exam-preview'>$fullQuestionForm</div>$report</form> text/html}]
  set f [::xowiki::Form new \
             -destroy_on_cleanup \
             -set name en:question \
             -form [subst {<form>$text$marked$footer</form> text/html}] \
             -text {} \
             -anon_instances t \
             -form_constraints $full_fc \
            ]
}

########################################################################
#
# Object specific operations
#
########################################################################

:object-specific {

  set ctx [:wf_context]
  set container [$ctx wf_container]
  if {$ctx ne $container} {
    $ctx forward load_form $container %proc $ctx
  }

  ${container}::Property return_url -default "" -allow_query_parameter true

  if {${:state} eq "done"} {
    set done_actions republish
    set combined_form_info [::xowf::test_item::question_manager combined_question_form [self]]

    #
    # We could allow open_submission_review only when autograde is
    # possible, but apparently, it makes as well sense for other
    # open text answers
    #
    lappend done_actions open_submission_review
    #if {[dict get $combined_form_info autograde]} {
    #  lappend done_actions open_submission_review
    #}
    set swa_done_actions [concat $done_actions restart]

    ${container}::done actions $done_actions
    ${container}::done in_role swa [subst {
      -actions {$swa_done_actions}
    }]
  }

  #
  # Unset the actual query return_url, since we want to use it via
  # property.  In some cases, we have to set it explicitly from the
  # property, e.g. in www-delete.
  #
  ::xo::cc unset_query_parameter return_url

  ########################################################################
  # web-callable method "delete"
  #
  # Delete the workflow instance and all its associated data.
  #
  :proc www-delete {} {
    ::xo::cc set_query_parameter return_url [:property return_url]
    xowf::test_item::answer_manager delete_all_answer_data [self]
    next
  }

  ########################################################################
  # web-callable method "print-answer-table"
  #
  # Print the answers in a tabular form.
  #
  :proc www-print-answer-table {} {
    set HTML ""
    set withAnswerColumns [${:package_id} query_parameter with_answers:boolean 0]

    set wf [xowf::test_item::answer_manager get_answer_wf [self]]
    if {$wf ne ""} {
      #set form_info [::xowf::test_item::question_manager combined_question_form -with_numbers [self]]

      set items [xowf::test_item::answer_manager get_wf_instances $wf]
      set items2 [$items deep_copy]
      foreach i [$items2 children] {
        $i set online-exam-userName [acs_user::get_element -user_id [$i creation_user] -element username]
        $i set online-exam-fullName [::xo::get_user_name [$i creation_user]]
      }
      set HTML [::xowf::test_item::answer_manager results_table \
                    -package_id ${:package_id} \
                    -items $items2 \
                    -state * \
                    -with_answers $withAnswerColumns \
                    [self]]
      $items2 destroy
    }
    if {$HTML eq ""} {
      set HTML "#xowiki.no_data#"
    } else {
      set HTML "<h1>#xowf.online-exam-results-table#</h1>$HTML"
    }
    set return_url [[$wf package_id] query_parameter local_return_url:localurl [:pretty_link]]
    append HTML "<hr><p><a class='btn btn-default' href='$return_url'>#xowiki.back#</a></p>\n"

    xo::Page requireCSS /resources/xowf/test-item.css
    :www-view $HTML
  }

  ########################################################################
  # web-callable method "print-participants"
  #
  # Print participants in a tabular form.
  #
  :proc www-print-participants {} {
    set HTML ""
    set wf [xowf::test_item::answer_manager get_answer_wf [self]]
    if {$wf ne ""} {
      set items [xowf::test_item::answer_manager get_wf_instances $wf]
      set items2 [$items deep_copy]
      foreach i [$items2 children] {
        $i set online-exam-userName [acs_user::get_element -user_id [$i creation_user] -element username]
        $i set online-exam-fullName [::xo::get_user_name [$i creation_user]]
      }
      set HTML [::xowf::test_item::answer_manager participants_table \
                    -package_id ${:package_id} \
                    -items $items2 \
                    -state * \
                    [self]]
      $items2 destroy
    }
    if {$HTML eq ""} {
      set HTML "#xowiki.no_data#"
    } else {
      set HTML "<h3>#xowf.Participants#</h3>$HTML"
    }
    set return_url [[$wf package_id] query_parameter local_return_url:localurl [:pretty_link]]
    append HTML "<hr><p><a class='btn btn-default' href='$return_url'>#xowiki.back#</a></p>\n"

    :www-view $HTML

  }

  ########################################################################
  # web-callable method "view-my-exam "
  #
  # Provide feedback to the student about the results.
  #
  :proc www-view-my-exam {} {
    if {${:state} eq "submission_review"} {
      ::xo::cc set_query_parameter creation_user [ad_conn user_id]
      ::xo::cc set_query_parameter as_student 1
      :www-print-answers
    } else {
      :www-view "#xowf.Exam-review-not-open#"
    }
  }

  ########################################################################
  # web-callable method "exam-summary"
  #
  # Print a summary of the exam-questions.
  #
  :proc www-exam-summary {} {
    :www-view [::xowf::test_item::question_manager exam_summary [self]]
  }

  ########################################################################
  # web-callable method "print-answers"
  #
  # Print the answers in a somewhat printer friendly way.
  #
  :proc www-print-answers {} {
    set as_student    [:query_parameter as_student:boolean 0]
    set filter_id     [:query_parameter id:integer ""]
    set creation_user [:query_parameter creation_user:integer ""]
    set revision_id   [:query_parameter rid:integer ""]
    set form_objs     [:query_parameter fos:integer ""]
    set export        [:query_parameter export:boolean 0]
    set grading       [:query_parameter grading:alnum ""]

    set combined_form_info [::xowf::test_item::question_manager combined_question_form [self]]
    set autograde   [dict get $combined_form_info autograde]
    set totalPoints [::xowf::test_item::question_manager total_points \
                         -max_items [:property max_items ""] \
                         $combined_form_info]
    if {$form_objs ne "" && $form_objs ni [dict get $combined_form_info question_objs]} {
      ns_log warning "inclass-exam: ignore invalid form_obj '$form_objs';" \
          "valid [dict get $combined_form_info question_objs]"
    }
    #
    # The management of the grading scheme has to be extended. For the
    # time being, we have a single grading scheme with the option to
    # round to full points or not. When an exam has less than 40
    # points, we do not round per default, since this rounding could
    # provide more than 1 percent of the result. This should be made
    # configurable (also in www-print-answer-table, which is not used
    # right now).
    #
    if {$grading eq ""} {
      set grading [expr {$totalPoints < 40 ? "wi1_noround" : "wi1"}]
    }

    set grading_scheme ::xowf::test_item::grading::$grading
    if {[info commands $grading_scheme] eq ""} {
      set grading_scheme ::xowf::test_item::grading::wi1
    }
    #ns_log notice "USE grading_scheme $grading_scheme"

    set grade_dict {}
    set grade_csv ""

    #
    # Provide quick mapping from the mangled attribute name to the question obj.
    #
    set nameToQuestionObj [xowf::test_item::renaming_form_loader \
                               name_to_question_obj_dict \
                               [dict get $combined_form_info question_objs]]

    set ctx [::xowf::Context require [self]]
    set wf [xowf::test_item::answer_manager get_answer_wf [self]]

    if {$wf ne ""} {

      set items [xowf::test_item::answer_manager get_wf_instances \
                     {*}[expr {$creation_user ne "" ? "-creation_user $creation_user" : ""}] \
                     {*}[expr {$filter_id ne "" ? "-item_id $filter_id" : ""}] \
                     $wf]
      set withSignature [expr {[dict exists ${:instance_attributes} signature]
                               ? [dict get ${:instance_attributes} signature]
                               : 0 }]
      set examTitle ${:title}
      set do_stream [expr {[llength [$items children]] > 100}]

      #
      # Add a simple print button for the unaware that makes it easy
      # to print the exam protocol to PDF and use e.g. a pdf-tool to
      # annotate free text answers.
      #
      set HTML {
        <button id="print-button">
          <span class='glyphicon glyphicon-print' aria-hidden='true'></span> print
        </button>
      }

      template::add_event_listener \
          -id print-button \
          -event click \
          -preventdefault=false \
          -script "window.print();"
      append HTML [template::collect_body_scripts]

      ::xo::cc set_parameter template_file view-plain-master
      ::xo::cc set_parameter MenuBar 0
      template::head::add_link -rel stylesheet -href /resources/xowf/test-item.css

      if {[llength $form_objs] > 0} {
        append HTML "<h2>#xowf.question#: [ns_quotehtml [[lindex $form_objs 0] title]]</h2>\n"
      } elseif {$as_student} {
        set userName [acs_user::get_element -user_id [ad_conn user_id] -element username]
        set fullName [::xo::get_user_name  [ad_conn user_id]]
        set heading "$userName - $fullName"
        append HTML "<h2>#xowf.online-exam-review-protocol# - $heading</h2>\n"
      } else {
        append HTML "<h2>#xowf.online-exam-protocol#</h2>\n"
      }

      if {$do_stream} {
        # ns_log notice STREAM-[info level]-$::template::parse_level
        uplevel #$::template::parse_level [subst {set title "${:title}"; set context .}]
        ad_return_top_of_page [ad_parse_template \
                                   -params [list context title] \
                                   [template::streaming_template]]
        ns_write [subst {
          <div class=''main-content>
          <div class='xowiki-content' style='padding-left:15px;'>
          <h1>[ns_quotehtml ${:title}]</h1>
          [lang::util::localize $HTML]
        }]
        set HTML ""
      }

      if {$revision_id ne ""} {
        set r [::xowiki::FormPage get_instance_from_db -revision_id $revision_id]
        if {[$r item_id] ni [lmap i [$items children] {$i item_id}]} {
          error "invalid revision id '$revision_id' provided"
        }
        $items destroy
        set items [::xo::OrderedComposite new -destroy_on_cleanup]
        $items add $r
      }

      if {$export} {
        set recutil [xowf::test_item::answer_manager recutil_create \
                         -clear \
                         -exam_id [$wf parent_id] \
                         -fn [expr {$filter_id eq "" ? "all.rec" : "$filter_id.rec"}]
                    ]
      }

      foreach i [$items children] {
        $i set online-exam-userName [acs_user::get_element -user_id [$i creation_user] -element username]
        $i set online-exam-fullName [::xo::get_user_name [$i creation_user]]
      }

      $items orderby online-exam-userName
      foreach i [$items children] {
        set userName [$i set online-exam-userName]
        set fullName [$i set online-exam-fullName]

        #if {[$i state] ne "done"} {
        #  ns_log notice "online-exam: submission of $userName is not finished (state [$i state])"
        #  #continue
        #}

        set revisions [$i get_revision_sets]
        if {[llength $revisions] <=1 } {
          # just an initial revision
          ns_log notice "online-exam: submission of $userName is empty. Ignoring."
          continue
        }

        #
        # The call to "render_content" calls actually the
        # "summary_form" of online/inclass-exam-answer.wf when the submit
        # instance is in state "done". We set the __feedback_mode to
        # get the auto-correction included.
        #
        foreach f [::xowiki::formfield::FormField info instances -closure] {
          #ns_log notice "FF could DESTROY $f [$f name]"
          if {[string match *_ [$f name]]} {
            #ns_log notice "FF DESTROY $f [$f name]"
            $f destroy
          }
        }
        $wf form_field_flush_cache

        set achieved_points {}
        xo::cc eval_as_user -user_id [$i creation_user] {
          $i set __feedback_mode 2
          $i set __form_objs $form_objs
          set question_form [$i render_content]

          if {$export} {
            xowf::test_item::answer_manager export_answer \
                -user_answers $i \
                -html $question_form \
                -combined_form_info $combined_form_info \
                -recutil $recutil
          }
          if {$withSignature || $autograde} {
            set answerAttributes [xowf::test_item::renaming_form_loader \
                                      answer_attributes [$i instance_attributes]]
            if {$autograde} {
              set achieved_points [xowf::test_item::answer_manager achieved_points \
                                       -answer_object $i -answer_attributes $answerAttributes]
              dict set achieved_points totalPoints $totalPoints
              #ns_log notice "==== www-print-answers: $userName achieved_points $achieved_points"
              #foreach detailInfo [dict get $achieved_points details] {
              #  set questionObj [dict get $nameToQuestionObj [dict get $detailInfo attributeName]]
              #  ns_log notice ".... $detailInfo item_id [$questionObj item_id]"
              #}
            }
          }
        }

        if {$withSignature} {
          set sha256 [ns_md string -digest sha256 $answerAttributes]
          set signatureString "<div class='signature'>online-exam-actual_signature: $sha256</div>\n"
          set submissionSignature [$i property signature ""]
          if {$submissionSignature ne ""} {
            append signatureString "<div>#xowf.online-exam-submission_signature#: $submissionSignature</div>\n"
          }
        } else {
          set signatureString ""
        }

        set time [::xo::db::tcl_date [$i property _last_modified] tz_var]
        set pretty_date [clock format [clock scan $time] -format "%Y-%m-%d"]

        if {$filter_id ne "" && [:property proctoring] eq "t"} {
          set user_id [$i creation_user]
          set img_url [:pretty_link -query m=proctor-image&user_id=$user_id]

          set proctoring_dir [proctoring::folder \
                                  -object_id ${:item_id} \
                                  -user_id $user_id]
          set files [glob -nocomplain -directory $proctoring_dir *.*]
          #ns_log notice "proctoring_dir $proctoring_dir files $files"

          if {$revision_id ne ""} {
            set filtered_revisions [xowf::test_item::answer_manager revisions_up_to $revisions $revision_id]
          } else {
            set filtered_revisions $revisions
          }

          set start_date  [ns_set get [lindex $filtered_revisions 0] creation_date]
          set end_date    [ns_set get [lindex $filtered_revisions end] creation_date]
          set start_clock [clock scan [::xo::db::tcl_date $start_date tz_var]]
          set end_clock   [clock scan [::xo::db::tcl_date $end_date tz_var]]

          set image ""
          #ns_log notice "start date $start_date end_date $end_date / $start_clock $end_clock"
          foreach f $files {
            #ns_log notice "check: $f"
            if {[regexp {/([^/]+)-(\d+)[.](webm|png|jpeg)$} $f . type stamp ext]} {
              set inWindow [expr {$stamp >= $start_clock && $stamp <= $end_clock}]
              ns_log notice "parsed $type $stamp $ext $inWindow $stamp \
                [clock format $stamp -format {%m-%d %H:%M:%S}] >= \
                $start_clock ([expr {$stamp >= $start_clock}]) \
                && $stamp <= $end_clock ([expr {$stamp <= $end_clock}])"
              if {$inWindow} {
                dict set image $stamp $type $ext
              }
            }
          }
          set markup ""
          foreach ts [lsort -integer [dict keys $image]] {
            #ns_log notice "ts $ts [dict get $image $ts]"
            append markup [subst {<div>[clock format $ts -format {%Y-%m-%d %H:%M:%S}]</div>}]
            append markup {<div style="display: flex">}
            foreach type {camera-image desktop-image} {
              if {[dict exists $image $ts $type]} {
                set ext [dict get $image $ts $type]
                append markup [subst {<img height="240" src="$img_url&type=$type&ts=$ts&e=$ext">}]
              }
            }
            if {[dict exists $image $ts camera-audio]} {
              set ext [dict get $image $ts camera-audio]
              append markup [subst {<audio controls src="$img_url&type=camera-audio&ts=$ts&e=$ext" type="video/webm"></audio>}]
            }
            append markup </div>\n
          }

          set question_form [subst {
            <div class="container">
              <div class="row">
                <div class="col-md-6">$question_form</div>
                <div class="col-md-6">$markup</div>
              </div>
            </div>
          }]
        }
        if {[llength $form_objs] == 0} {
          set view [expr {$as_student
                          ? "student"
                          : $filter_id ne ""
                          ? "revision_overview"
                          : "default"}]
          set gradingInfo [$grading_scheme print -achieved_points $achieved_points]
          set grandingPanel [expr {[dict exists  $gradingInfo panel] ? [dict get $gradingInfo panel] : ""}]
          set runtime_panel [xowf::test_item::answer_manager runtime_panel \
                                 -revision_id $revision_id \
                                 -view $view \
                                 -grading_info $grandingPanel \
                                 $i]
          if {$autograde} {
            set grade [$grading_scheme grade -achieved_points $achieved_points]
            ns_log notice "CSV $userName\t[dict get $gradingInfo csv]"
            dict incr grade_dict $grade
            append grade_csv $userName\t[dict get $gradingInfo csv]\n
          }
        } else {
          set runtime_panel ""
        }

        set heading "$userName · $fullName · $pretty_date"
        append HTML [subst {
          <div class='single_exam'>
          <div class='runtime-data'>
          [expr {$as_student ? "" : "<h2>$heading</h2>"}]
          $runtime_panel
          </div>
          $signatureString
          $question_form
          </div>
        }]

        if {$do_stream} {
          ns_write [lang::util::localize $HTML]
          set HTML " "
        }
      }
      if {$export} {
        $recutil destroy
      }
    }

    if {$HTML eq ""} {
      append HTML "#xowiki.no_data#"
    }

    if {!$as_student} {
      if {$autograde} {
        append HTML <p>[xowf::test_item::answer_manager grading_table -csv $grade_csv $grade_dict]</p>
      }

      set return_url [:query_parameter local_return_url:localurl [:pretty_link]]
      append HTML "<hr><p><a class='btn btn-default' href='$return_url'>#xowiki.back#</a></p>\n"
    }
    #::xo::cc set_parameter template_file view-plain-master
    #::xo::cc set_parameter MenuBar 0
    #xo::Page requireCSS /resources/xowf/test-item.css

    if {$do_stream} {
      ns_write [lang::util::localize $HTML]
      set HTML ""
       [$wf package_id] set __continuation ad_progress_bar_end
      return ""
    } else {
      :www-view $HTML
    }
  }

  ########################################################################
  # web-callable method "proctoring-display"
  #
  :proc www-proctoring-display {} {
    #
    # Display the proctoring files collected for this exam using the
    # UI by the proctoring-support package.
    #
    # By this is also possible to delete the proctoring files, either
    # for the whole exam or for the single participant.
    #

    ${:package_id} return_page -adp /packages/proctoring-support/lib/proctoring-display -variables {
        {object_id ${:item_id}}
    }
  }

  ########################################################################
  # web-callable method "answer"
  #
  :proc www-answer {} {
    #
    # Create or use an answering workflow for the current exam. This
    # is a convenience routine to shorten the published URL.
    #
    # Make sure that no-one tries to start the answer workflow in a
    # state different to "published".
    #
    if {[:property _state] ne "published"} {
      :util_user_message -html -message "Cannot start answer workflow in this state"
    } else {
      set wf [xowf::test_item::answer_manager get_answer_wf [self]]
      set proctoring [:property proctoring]
      if {$proctoring ne "" && $proctoring} {
        set po [:property proctoring_options]
        set cLink [export_vars -base [:pretty_link] {
          {m proctor} {link "[:pretty_link -query m=proctor-answer&proctoring_options=$po]"}
        }]
        ::${:package_id} returnredirect $cLink
      } else {
        $wf www-create-or-use -parent_id [:item_id]
      }
    }
  }
  :proc www-proctor-answer {} {
    #
    # Start answering an exam in proctored mode
    #
    if {[:property _state] ne "published"} {
      :util_user_message -html -message "Cannot start answer workflow in this state"
    } else {
      set wf [xowf::test_item::answer_manager get_answer_wf [self]]
      $wf www-create-or-use -parent_id [:item_id]
    }
  }

  :proc www-qrcode {} {
    #
    # Produce a QR code with an answer link
    #
    set aLink [:pretty_link -absolute true -query m=answer]
    set fn /tmp/qr-${:item_id}.png
    exec qrencode -o $fn -l h $aLink
    ns_returnfile 200 image/png $fn
    ad_script_abort
  }

  :proc www-proctor {} {
    #
    # Redirect the exam to an iframe for implementing proctoring.  The
    # basic idea is that the web application turns on the camera and
    # keeps the iframe while the user is iterating through the exam.
    # The line "<h1>You are being proctored!</h1>" is just a
    # placeholder and has to be replaced with real code.
    #
    set link [:query_parameter link:localurl ""]

    ::xo::cc set_parameter template_file view-plain-master
    ::xo::cc set_parameter MenuBar 0

    set proctoring_template /packages/proctoring-support/lib/proctored-page
    if {[file exists [acs_root_dir]${proctoring_template}.adp]} {
      set object_id ${:item_id}
      set object_url $link
      set examination_statement_p [expr {![string match *p.try_out_mode=1* $link]}]
      set proctoring_options [:property proctoring_options "d c a s"]
      foreach proctoring_parm {d c a s} flag {desktop_p camera_p audio_p examination_statement_p} {
        set $flag [expr {$proctoring_parm in $proctoring_options}]
      }
      set preview_p [expr {$desktop_p || $camera_p || $audio_p}]

      #
      # Set the max interval between screen captures to 30s (default is 60s)
      #
      set max_ms_interval 30000

      ${:package_id} return_page -adp $proctoring_template -variables {
        object_id
        object_url
        preview_p
        desktop_p
        camera_p
        audio_p
        max_ms_interval
        examination_statement_p
        {check_active_p false}
      }
    } else {
      #
      # Minimal fallback in case the proctoring-support is not installed
      #
      return [:www-view [subst {
        <!-- ... proctor::start_dialog... -->
        <h1>You ([xo::cc user_id]) are being proctored in exam ${:object_id}!</h1>
        <iframe src="$link" width="100%" height="600"></iframe>
      }]]
    }
  }

  :proc www-proctor-image {} {
    #
    # View a proctored image
    #
    set type [${:package_id} query_parameter type:ascii ""]
    set ts   [${:package_id} query_parameter ts:integer ""]
    set ext  [${:package_id} query_parameter e:wordchar ""]
    set user_id [${:package_id} query_parameter user_id:integer ""]
    set proctoring_dir [proctoring::folder \
                            -object_id ${:item_id} \
                            -user_id $user_id]
    set png_path $proctoring_dir/$type-$ts.$ext
    #ns_log notice "image: $png_path ... [ad_file exists $$png_path]"
    ns_returnfile 200 [ns_guesstype $ts.$ext] $png_path
    ad_script_abort
  }

  ########################################################################
  # AJAX call "poll"
  #
  :proc www-poll {} {
    #
    # Return statistics about working and finished exams.
    #
    set wf [xowf::test_item::answer_manager get_answer_wf [self]]
    set answers [xowf::test_item::answer_manager get_answers $wf]
    set answered [xowf::test_item::answer_manager get_answers -state done $wf]
    ns_return 200 text/plain [llength $answered]/[llength $answers]
    #ns_log notice "MASTER POLL [self] ${:name}, returned [llength $answered]/[llength $answers]"
    ad_script_abort
  }

  ########################################################################
  # AJAX call "send-participant-message"
  #
  :proc www-send-participant-message {} {
    #
    # Send a message to a participant
    #
    ::xowiki::includelet::personal-notification-messages message_add \
        -notification_id ${:item_id} \
        -to_user_id [${:package_id} query_parameter user_id:integer ""] \
        -payload [list msg [ns_queryget msg] from [xo::cc user_id] urgency [ns_queryget urgency]]

    ns_return 200 text/plain ok
    ad_script_abort
  }

}

#
# Local variables:
#    mode: tcl
#    tcl-indent-level: 2
#    indent-tabs-mode: nil
# End:
